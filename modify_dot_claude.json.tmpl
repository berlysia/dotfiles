#!/bin/bash

# ~/.claude.json „ÅÆ„Ç∑„É≥„Éó„É´„Éë„ÉÉ„ÉÅ„Éô„Éº„Çπ„Éû„Éº„Ç∏„Çπ„ÇØ„É™„Éó„Éà
# JSONÂΩ¢Âºè„Å´ÁâπÂåñ„Åó„ÅüËªΩÈáè„Éë„ÉÉ„ÉÅÂá¶ÁêÜ

set -euo pipefail

# „Éû„Éº„Ç∏„É¢„Éº„ÉâË®≠ÂÆö
MERGE_MODE="${MERGE_MODE:-AUTO}"

# ‰ΩúÊ•≠Áî®‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´
TEMP_DIR=$(mktemp -d)
EXISTING_FILE="$TEMP_DIR/existing.json"
CHEZMOI_FILE="$TEMP_DIR/chezmoi.json"

# „Ç®„É©„ÉºÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Ê®ôÊ∫ñÂÖ•Âäõ„Åã„ÇâÊó¢Â≠ò„ÅÆ„Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÇíË™≠„ÅøËæº„Åø
cat > "$EXISTING_FILE"

# chezmoiÁÆ°ÁêÜ„ÅÆË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø
cat > "$CHEZMOI_FILE" << 'EOF'
{{ includeTemplate ".claude.config.json" . }}
EOF

# JSONÊ≠£Ë¶èÂåñÔºàÊØîËºÉÁî®Ôºâ
normalize_json() {
    local file="$1"
    if command -v jq >/dev/null 2>&1; then
        if jq --sort-keys . "$file" > "$file.normalized" 2>/dev/null; then
            mv "$file.normalized" "$file"
        else
            echo "‚ö†Ô∏è  Warning: Invalid JSON in $file" >&2
        fi
    fi
}

# „Éë„ÉÉ„ÉÅÁîüÊàê
generate_patch() {
    # JSONÊ≠£Ë¶èÂåñ„Åó„Å¶ÊØîËºÉ
    normalize_json "$EXISTING_FILE"
    normalize_json "$CHEZMOI_FILE"
    
    if diff -u "$EXISTING_FILE" "$CHEZMOI_FILE" > /dev/null 2>/dev/null; then
        echo "‚úÖ No configuration changes detected" >&2
        cat "$EXISTING_FILE"
        return 1
    else
        return 0
    fi
}

# JSONÂ∑ÆÂàÜ„Çí„Çè„Åã„Çä„ÇÑ„Åô„ÅèË°®Á§∫
show_json_diff() {
    echo "üîç JSON changes summary:" >&2
    
    # ËøΩÂä†„Åï„Çå„Åü„Ç≠„Éº
    local added_keys=$(jq -r --slurpfile existing "$EXISTING_FILE" --slurpfile chezmoi "$CHEZMOI_FILE" '
        def find_keys($obj; $path):
            if ($obj | type) == "object" then
                $obj | to_entries[] | find_keys(.value; $path + [.key])
            else
                $path
            end;
        
        [find_keys($chezmoi[0]; [])] - [find_keys($existing[0]; [])] | 
        .[] | join(".")
    ' 2>/dev/null)
    
    # Â§âÊõ¥„Åï„Çå„Åü„Ç≠„Éº
    local changed_keys=$(jq -r --slurpfile existing "$EXISTING_FILE" --slurpfile chezmoi "$CHEZMOI_FILE" '
        def find_changes($existing; $chezmoi; $path):
            if ($existing | type) == "object" and ($chezmoi | type) == "object" then
                reduce ($existing | keys_unsorted[]) as $key ([]; 
                    if $chezmoi | has($key) then
                        if ($existing[$key] | type) == "object" and ($chezmoi[$key] | type) == "object" then
                            . + find_changes($existing[$key]; $chezmoi[$key]; $path + [$key])
                        elif $existing[$key] != $chezmoi[$key] then
                            . + [$path + [$key]]
                        else
                            .
                        end
                    else
                        .
                    end
                )
            else
                []
            end;
        
        find_changes($existing[0]; $chezmoi[0]; []) | .[] | join(".")
    ' 2>/dev/null)
    
    if [ -n "$added_keys" ]; then
        echo "  ‚ûï Added: $added_keys" >&2
    fi
    
    if [ -n "$changed_keys" ]; then
        echo "  üîÑ Changed: $changed_keys" >&2
    fi
    
    echo "" >&2
    echo "üìã Unified diff:" >&2
    head -50 "$PATCH_FILE" >&2  # ÊúÄÂàù„ÅÆ50Ë°å„ÅÆ„ÅøË°®Á§∫
}

# „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñÈÅ©Áî®
apply_patch() {
    case "$MERGE_MODE" in
        "INTERACTIVE")
            echo "Choose action:" >&2
            echo "1) Apply changes (use chezmoi configuration)" >&2
            echo "2) Smart merge (deep merge objects)" >&2
            echo "3) Open merge tool" >&2
            echo "4) Keep existing configuration" >&2
            echo "5) Manual edit" >&2
            echo "" >&2
            
            while true; do
                read -p "Enter choice [1-5]: " choice
                case $choice in
                    1)
                        echo "üì• Applying chezmoi configuration..." >&2
                        cp "$CHEZMOI_FILE" "$EXISTING_FILE"
                        validate_and_output
                        return 0
                        ;;
                    2)
                        smart_merge
                        return 0
                        ;;
                    3)
                        open_merge_tool
                        return 0
                        ;;
                    4)
                        echo "üìÑ Keeping existing configuration" >&2
                        validate_and_output
                        return 0
                        ;;
                    5)
                        manual_edit
                        return 0
                        ;;
                    *)
                        echo "Invalid choice. Please enter 1-5." >&2
                        ;;
                esac
            done
            ;;
        "AUTO")
            echo "ü§ñ Auto-applying chezmoi configuration..." >&2
            smart_merge
            ;;
        "FORCE")
            echo "üí™ Force-applying chezmoi configuration..." >&2
            cp "$CHEZMOI_FILE" "$EXISTING_FILE"
            validate_and_output
            ;;
    esac
}

# „Çπ„Éû„Éº„Éà„Éû„Éº„Ç∏Ôºàjq‰ΩøÁî®Ôºâ
smart_merge() {
    if ! command -v jq >/dev/null 2>&1; then
        echo "‚ùå jq not available for smart merge" >&2
        return 1
    fi
    
    echo "üß† Performing smart JSON merge..." >&2
    
    jq -s '
        def deep_merge($existing; $new):
            if ($existing | type) == "object" and ($new | type) == "object" then
                $existing + reduce ($new | keys_unsorted[]) as $key ($existing;
                    if $existing | has($key) then
                        .[$key] = deep_merge($existing[$key]; $new[$key])
                    else
                        .[$key] = $new[$key]
                    end
                )
            else
                $new
            end;
        
        deep_merge(.[0]; .[1])
    ' "$EXISTING_FILE" "$CHEZMOI_FILE" > "$EXISTING_FILE.merged"
    
    mv "$EXISTING_FILE.merged" "$EXISTING_FILE"
    echo "‚úÖ Smart merge completed" >&2
    validate_and_output
}

# „Éû„Éº„Ç∏„ÉÑ„Éº„É´„ÇíÈñã„Åè
open_merge_tool() {
    if command -v code >/dev/null 2>&1; then
        echo "üõ†Ô∏è  Opening VS Code merge editor..." >&2
        code --diff "$EXISTING_FILE" "$CHEZMOI_FILE" --wait
        validate_and_output
    elif command -v vimdiff >/dev/null 2>&1; then
        echo "üõ†Ô∏è  Opening vimdiff..." >&2
        vimdiff "$EXISTING_FILE" "$CHEZMOI_FILE"
        validate_and_output
    else
        echo "‚ùå No suitable merge tool found" >&2
        manual_edit
    fi
}

# ÊâãÂãïÁ∑®ÈõÜ
manual_edit() {
    local editor="${EDITOR:-nano}"
    echo "‚úèÔ∏è  Opening editor ($editor)..." >&2
    echo "Files available:" >&2
    echo "  Current: $EXISTING_FILE" >&2
    echo "  Target:  $CHEZMOI_FILE" >&2
    echo "" >&2
    
    $editor "$EXISTING_FILE"
    validate_and_output
}

# JSONÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØ„Å®Âá∫Âäõ
validate_and_output() {
    if command -v jq >/dev/null 2>&1; then
        if jq . "$EXISTING_FILE" > /dev/null 2>&1; then
            jq . "$EXISTING_FILE"
        else
            echo "‚ùå Invalid JSON detected" >&2
            cat "$EXISTING_FILE"
            exit 1
        fi
    else
        cat "$EXISTING_FILE"
    fi
}

# „É°„Ç§„É≥Âá¶ÁêÜ
main() {
    if generate_patch; then
        apply_patch
    fi
}

main