# Development Guidelines

## Language
- Japanese for discussion, English for code

## Workflow
1. **Explore** - Understand codebase and requirements
2. **Plan** - Design solution with clear steps
3. **Code** - Implement following best practices
4. **Commit** - Clean, meaningful commits

## Development Principles

### Code Quality
- Clean formatting, descriptive names, idiomatic patterns
- Comments explain why code exists (its purpose), not what changed
- Comprehensive error handling and parallelization

### Developer Experience
- Minimize developer friction
- Thorough planning before implementation
- Root cause analysis for bug fixes
- Create scripts for repetitive tasks
- **Decision transparency**: When changing approach mid-task, explicitly explain the reasoning and new plan before proceeding

### Architecture
- **Libraries**: Minimal dependencies, prefer built-ins
- **Design**: Respect existing architecture, maintain unidirectional dependency graph
- **Documentation**: Record significant decisions in ADRs (Architecture Decision Records)
- **Patterns**: Abstract repeated patterns, use tools like `similarity-ts` for detection

### Testing
- Follow t-wada's TDD style
- Strict Red-Green-Refactor cycle
- Tests must pass before commits

## TypeScript Standards
- Package manager: `pnpm`
- Linting: `biome`
- Testing for browser: `Vitest`
- Testing for CLI: `node:test`
- No `any` types
- Prefer `async/await`

## Security Requirements
- **Prohibited**: Hardcoded secrets, unvalidated inputs, suppressed errors
- **Required**: Input validation, environment variables, comprehensive logging, passing lint/test

## Git Workflow

### Worktree Management
- **Create**: `git-worktree-create <branch-name>`
  - Location: `.git/worktree/` directory
  - Auto-creates branch from current if needed
  - Uses existing local/remote branches when available
  
- **Cleanup**: `git-worktree-cleanup`
  - Safely removes completed worktrees
  - Preserves worktrees with uncommitted changes or unpushed commits
  - Auto-prunes after deletion

### Commit Standards
- All tests and lints must pass
- Clear, descriptive commit messages
- Use semantic commits with conventional prefixes (feat:, fix:, docs:, etc.)
- Break large changes into logical, atomic commits
- Use `/commit` command for guided semantic commit workflow

## Useful Commands

### File Processing
- **tee**: Output to file and stdout
  - `command | tee file.txt`
  - `command | tee -a file.txt` (append)

### Code Analysis
- **similarity-ts**: Detect code duplication
  - `similarity-ts src/`
  - `similarity-ts --threshold 0.8 src/`

### Git Tools
- **git-sequential-stage**: Stage specific hunks for semantic commits
  - `git-sequential-stage -patch="changes.patch" -hunk="file.go:1,3,5"`
  - Used by `/commit` command for precise staging

## Knowledge Management
- Record learnings in `.claude/memory/<timestamp>-<summary>.md`

## MCP (Model Context Protocol) Tools

### Available MCP Servers
- **readability**: Web content extraction
  - `mcp__readability__read_url_content_as_markdown` - Extract content from URLs as Markdown
  - Useful for reading documentation and blog articles

- **playwright**: Browser automation
  - Web page manipulation and screenshot capture
  - Visual verification of CSS implementation results

- **context7**: Context management
  - Up-to-date documentation for any library

### MCP Best Practices
1. **Web Information Gathering**: Prefer readability MCP tool over WebFetch
2. **Browser Operations**: Use playwright for dynamic content instead of simple HTTP requests
3. **Resource Discovery**: Check available resources with `ListMcpResourcesTool`
4. **Error Handling**: Consider fallback strategies when MCP tools fail

## Specialized Agents

### Available Agents
- **cohesion-evaluator**: Internal module unity assessment
- **coupling-evaluator**: Inter-module dependency strength analysis
- **architecture-boundary-analyzer**: Architectural boundary validation and dependency direction analysis
- **interface-ergonomics-reviewer**: Software interface usability and design philosophy evaluation
- **resilience-analyzer**: System fault tolerance and reliability evaluation
- **data-contract-evolution-evaluator**: API/schema compatibility assessment
- **observability-evaluator**: Monitoring and alerting coverage analysis
- **release-safety-evaluator**: Deployment risk and safety validation
- **documentation-consistency-reviewer**: Documentation accuracy and consistency verification
- **logic-validator**: Logical consistency validation between actions and instructions
- **architecture-integration-orchestrator**: Comprehensive architecture quality assessment coordination

### Agent Usage Guidelines

**Proactive Agent Usage:**
- **logic-validator**: MUST be called after every significant decision or action to verify logical consistency
  - Before making assumptions about file contents or system state
  - After claiming task completion without verification
  - When changing approach mid-task
- **documentation-consistency-reviewer**: Call after any file modification to ensure documentation remains accurate

**Code Quality Assessment:**
- Use **cohesion-evaluator** and **coupling-evaluator** for design quality analysis
- Use **architecture-boundary-analyzer** for dependency and boundary evaluation
- Use **architecture-integration-orchestrator** for comprehensive multi-dimensional assessment

**System Reliability:**
- Use **resilience-analyzer** for fault tolerance evaluation
- Use **observability-evaluator** for monitoring coverage assessment
- Use **release-safety-evaluator** before deployment decisions

**Critical Rule:**
Always gather evidence (read files, run tests, check actual state) before making decisions. Use **logic-validator** proactively to catch assumption-based reasoning.