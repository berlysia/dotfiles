{{- $pkgJson := output "cat" (joinPath .chezmoi.workingTree "package.json") | fromJson -}}
{{- $addSkillVersion := index $pkgJson.dependencies "add-skill" -}}
#!/usr/bin/env bash

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Constants
CHEZMOI_SOURCE_DIR="${CHEZMOI_SOURCE_DIR:-}"
YAML_FILE=""

# Check dependencies
check_dependencies() {
    local missing=()
    command -v mise &>/dev/null || missing+=("mise")
    command -v jq &>/dev/null || missing+=("jq")
    command -v chezmoi &>/dev/null || missing+=("chezmoi")

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}âŒ Missing dependencies: ${missing[*]}${NC}" >&2
        echo "   Install mise: https://mise.jdx.dev/" >&2
        echo "   Install jq: sudo apt-get install jq" >&2
        exit 1
    fi

    # daselã®å®Ÿè¡Œå¯èƒ½æ€§ç¢ºèª
    if ! mise x -- dasel version &>/dev/null; then
        echo -e "${RED}âŒ dasel not properly installed${NC}" >&2
        echo "   Install: mise install dasel -f" >&2
        exit 1
    fi
}

# YAML validation
validate_yaml() {
    local file=$1
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}âŒ File not found: $file${NC}" >&2
        exit 1
    fi

    if ! mise x -- dasel -i yaml -o json < "$file" &>/dev/null; then
        echo -e "${RED}âŒ Invalid YAML syntax${NC}" >&2
        exit 1
    fi
}

# YAML update with atomic replacement
update_yaml() {
    local jq_args="$1"
    local jq_filter="$2"
    local temp_json=$(mktemp)
    local temp_yaml=$(mktemp)
    local temp_json_new="${temp_json}.new"

    # Cleanup function
    cleanup_temp_files() {
        rm -f "$temp_json" "$temp_yaml" "$temp_json_new" 2>/dev/null || true
    }
    trap cleanup_temp_files RETURN

    # YAML â†’ JSON
    if ! mise x -- dasel -i yaml -o json < "$YAML_FILE" > "$temp_json"; then
        echo -e "${RED}âŒ YAML parse failed${NC}" >&2
        cleanup_temp_files
        trap - RETURN
        return 1
    fi

    # jq transformation
    if ! eval "jq $jq_args '$jq_filter' '$temp_json' > '$temp_json_new'"; then
        echo -e "${RED}âŒ jq transformation failed${NC}" >&2
        cleanup_temp_files
        trap - RETURN
        return 1
    fi

    # JSON â†’ YAML
    if ! mise x -- dasel -i json -o yaml < "$temp_json_new" > "$temp_yaml"; then
        echo -e "${RED}âŒ JSON to YAML conversion failed${NC}" >&2
        cleanup_temp_files
        trap - RETURN
        return 1
    fi

    # Show diff
    if diff -u "$YAML_FILE" "$temp_yaml"; then
        echo -e "${YELLOW}âš ï¸  No changes detected${NC}"
        cleanup_temp_files
        trap - RETURN
        return 0
    fi

    # Atomic replacement
    mv "$temp_yaml" "$YAML_FILE"
    echo -e "${GREEN}âœ… Updated successfully${NC}"
    cleanup_temp_files
    trap - RETURN
}

# Add skill
cmd_add() {
    local repo=$1
    local skill=$2

    [[ -z "$repo" || -z "$skill" ]] && {
        echo -e "${RED}Usage: add-skill add <repo> <skill>${NC}" >&2
        exit 1
    }

    echo -e "${BLUE}ğŸ“¦ Adding skill: $skill from $repo${NC}"

    local jq_args="--arg repo \"$repo\" --arg skill \"$skill\""
    local jq_filter='
def has_repo: .claude_skills.repositories | any(.repo == $repo);

if has_repo then
  .claude_skills.repositories |= (
    map(if .repo == $repo
        then .skills += [$skill]
        else .
        end)
    | map(.skills |= (unique | sort))
  )
else
  .claude_skills.repositories += [{"repo": $repo, "skills": [$skill]}]
end
'

    if update_yaml "$jq_args" "$jq_filter"; then
        echo -e "${BLUE}ğŸ’¡ Next: chezmoi apply${NC}"
    fi
}

# Remove skill
cmd_remove() {
    local skill=$1

    [[ -z "$skill" ]] && {
        echo -e "${RED}Usage: add-skill remove <skill>${NC}" >&2
        exit 1
    }

    echo -e "${BLUE}ğŸ—‘ï¸  Removing skill: $skill${NC}"

    local jq_args="--arg skill \"$skill\""
    local jq_filter='
.claude_skills.repositories |= (
  map(.skills |= map(select(. != $skill)))
  | map(select(.skills | length > 0))
)
'

    if update_yaml "$jq_args" "$jq_filter"; then
        echo -e "${BLUE}ğŸ’¡ Next: chezmoi apply${NC}"
    fi
}

# List skills
cmd_list() {
    echo -e "${BLUE}ğŸ“‹ Current skills configuration:${NC}"
    echo ""

    mise x -- dasel -i yaml -o json < "$YAML_FILE" | jq -r '
        .claude_skills.repositories[]
        | "[\(.repo)]" + "\n  " + (.skills | join("\n  "))
    '
}

# Search skills
cmd_search() {
    local repo=${1:-}

    [[ -z "$repo" ]] && {
        echo -e "${RED}Usage: add-skill search <repo>${NC}" >&2
        exit 1
    }

    echo -e "${BLUE}ğŸ” Searching skills in $repo...${NC}"
    pnpm dlx add-skill@{{ $addSkillVersion }} "$repo" --list
}

# Install skills
cmd_install() {
    echo -e "${BLUE}ğŸ“¦ Installing skills from configuration...${NC}"

    # YAMLã‹ã‚‰ãƒªãƒã‚¸ãƒˆãƒªãƒ»ã‚¹ã‚­ãƒ«æƒ…å ±ã‚’èª­ã¿å–ã‚Š
    local repos_json
    repos_json=$(mise x -- dasel -i yaml -o json < "$YAML_FILE" | jq '.claude_skills.repositories')

    # å…¨ã‚¹ã‚­ãƒ«ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    echo "$repos_json" | jq -c '.[]' | while read -r repo_entry; do
        local repo=$(echo "$repo_entry" | jq -r '.repo')
        local skills=$(echo "$repo_entry" | jq -r '.skills | join(" ")')

        echo -e "${BLUE}Installing from $repo: $skills${NC}"
        # shellcheck disable=SC2086
        pnpm dlx add-skill@{{ $addSkillVersion }} "$repo" --global --skill $skills --yes
    done

    echo -e "${GREEN}âœ… Installation completed${NC}"
}

# Help
cmd_help() {
    cat <<'EOF'
add-skill - Manage Claude Code skills in chezmoi

Usage:
  add-skill add <repo> <skill>     Add skill to configuration
  add-skill remove <skill>         Remove skill from configuration
  add-skill list                   Show current configuration
  add-skill search <repo>          Search available skills in repository
  add-skill install                Install all skills from configuration
  add-skill help                   Show this help

Examples:
  add-skill add vercel-labs/agent-skills web-design-guidelines
  add-skill remove web-design-guidelines
  add-skill list
  add-skill search vercel-labs/agent-skills
  add-skill install

After modifying configuration, run: chezmoi apply
EOF
}

# Main
main() {
    check_dependencies

    local subcommand=${1:-help}
    shift || true

    # YAML_FILE path resolution
    if [[ -z "$CHEZMOI_SOURCE_DIR" ]]; then
        CHEZMOI_SOURCE_DIR=$(chezmoi source-path 2>/dev/null || echo "$HOME/.local/share/chezmoi")
    fi
    YAML_FILE="$CHEZMOI_SOURCE_DIR/.chezmoidata/claude_skills.yaml"

    case "$subcommand" in
        add)
            validate_yaml "$YAML_FILE"
            cmd_add "$@"
            ;;
        remove)
            validate_yaml "$YAML_FILE"
            cmd_remove "$@"
            ;;
        list)
            validate_yaml "$YAML_FILE"
            cmd_list
            ;;
        search)
            cmd_search "$@"
            ;;
        install)
            validate_yaml "$YAML_FILE"
            cmd_install
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo -e "${RED}Unknown command: $subcommand${NC}" >&2
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
